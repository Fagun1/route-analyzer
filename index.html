<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Analyzer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #f5f5f5; }
        .container { display: flex; height: 100vh; }
        .sidebar { width: 300px; background: white; padding: 20px; overflow-y: auto; }
        .map { flex: 1; }
        #map { width: 100%; height: 100%; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .input-group input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        .btn { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
        .btn:hover { background: #0056b3; }
        .btn-secondary { background: #6c757d; }
        .btn-secondary:hover { background: #545b62; }
        .results { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; display: none; }
        .info { display: flex; justify-content: space-between; margin: 5px 0; }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 4px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: none; }
        .toast { position: fixed; top: 20px; right: 20px; background: #28a745; color: white; padding: 10px 20px; border-radius: 4px; z-index: 1000; }
        .toast.error { background: #dc3545; }
        .toast.warning { background: #ffc107; color: #000; }
        
        /* Traffic marker styles */
        .traffic-signal-marker {
            background: transparent;
            border: none;
            font-size: 16px;
        }
        
        .construction-marker {
            background: transparent;
            border: none;
            font-size: 16px;
        }
        
        .traffic-signal-marker:hover,
        .construction-marker:hover {
            transform: scale(1.2);
            transition: transform 0.2s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h2>Route Planner</h2>
            
            <div class="input-group">
                <label>Start Location</label>
                <input type="text" id="start" placeholder="Enter start address">
            </div>
            
            <div class="input-group">
                <label>End Location</label>
                <input type="text" id="end" placeholder="Enter destination">
            </div>
            
            <button class="btn" onclick="findRoute()">Find Route</button>
            <button class="btn btn-secondary" onclick="clearRoute()">Clear</button>
            
            <div class="results" id="results">
                <h3>Route Details</h3>
                <div class="info">
                    <span>Distance:</span>
                    <span id="distance">--</span>
                </div>
                <div class="info">
                    <span>Duration:</span>
                    <span id="duration">--</span>
                </div>
                <div class="info">
                    <span>Speed:</span>
                    <span id="speed">--</span>
                </div>
                <div class="info">
                    <span>Traffic Impact:</span>
                    <span id="traffic-impact">--</span>
                </div>
                <div class="info">
                    <span>Traffic Signals:</span>
                    <span id="traffic-signals">--</span>
                </div>
                <div class="info">
                    <span>Construction:</span>
                    <span id="construction">--</span>
                </div>
                <div class="info">
                    <span>Road Closures:</span>
                    <span id="closures">--</span>
                </div>
            </div>
        </div>
        
        <div class="map">
            <div id="map"></div>
            <div class="loading" id="loading">Calculating route...</div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // OpenStreetMap Traffic Service
        class OpenStreetMapTrafficService {
            constructor() {
                this.baseUrl = 'https://overpass-api.de/api/interpreter';
                this.cache = new Map();
                this.cacheTimeout = 300000; // 5 minutes cache
            }
            
            async getTrafficData(bounds) {
                const cacheKey = this.getBoundsKey(bounds);
                const cached = this.cache.get(cacheKey);
                
                if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
                    return cached.data;
                }
                
                const query = this.buildTrafficQuery(bounds);
                const data = await this.executeQuery(query);
                
                this.cache.set(cacheKey, {
                    data: data,
                    timestamp: Date.now()
                });
                
                return data;
            }
            
            buildTrafficQuery(bounds) {
                return `
[out:json][timeout:25];
(
  // Traffic signals
  node["highway"="traffic_signals"](${bounds});
  way["highway"="traffic_signals"](${bounds});
  
  // Speed limits
  way["maxspeed"](${bounds});
  
  // Traffic calming measures
  way["traffic_calming"](${bounds});
  
  // Road restrictions
  relation["type"="restriction"](${bounds});
  
  // Construction zones
  way["construction"](${bounds});
  node["construction"](${bounds});
  
  // Road closures
  way["access"="no"](${bounds});
  way["motor_vehicle"="no"](${bounds});
  
  // Bus lanes
  way["bus"]="yes"(${bounds});
  
  // One-way streets
  way["oneway"]="yes"(${bounds});
);
out geom;
`;
            }
            
            async executeQuery(query) {
                try {
                    const response = await fetch(this.baseUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: `data=${encodeURIComponent(query)}`
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    return await response.json();
                } catch (error) {
                    console.error('Overpass API error:', error);
                    return { elements: [] };
                }
            }
            
            getBoundsKey(bounds) {
                return `${bounds.south},${bounds.west},${bounds.north},${bounds.east}`;
            }
        }

        // Traffic Data Processor
        class TrafficDataProcessor {
            constructor() {
                this.trafficService = new OpenStreetMapTrafficService();
            }
            
            async processTrafficData(route, bounds) {
                const rawData = await this.trafficService.getTrafficData(bounds);
                return this.analyzeTrafficElements(rawData.elements, route);
            }
            
            analyzeTrafficElements(elements, route) {
                const trafficData = {
                    signals: [],
                    speedLimits: [],
                    restrictions: [],
                    construction: [],
                    closures: [],
                    busLanes: [],
                    oneWay: []
                };
                
                elements.forEach(element => {
                    switch (element.type) {
                        case 'node':
                            this.processNode(element, trafficData);
                            break;
                        case 'way':
                            this.processWay(element, trafficData);
                            break;
                        case 'relation':
                            this.processRelation(element, trafficData);
                            break;
                    }
                });
                
                return this.calculateTrafficImpact(trafficData, route);
            }
            
            processNode(node, trafficData) {
                if (node.tags) {
                    if (node.tags.highway === 'traffic_signals') {
                        trafficData.signals.push({
                            lat: node.lat,
                            lng: node.lon,
                            type: 'traffic_signal'
                        });
                    }
                    
                    if (node.tags.construction) {
                        trafficData.construction.push({
                            lat: node.lat,
                            lng: node.lon,
                            type: 'construction',
                            description: node.tags.construction
                        });
                    }
                }
            }
            
            processWay(way, trafficData) {
                if (way.tags) {
                    // Speed limits
                    if (way.tags.maxspeed) {
                        trafficData.speedLimits.push({
                            way: way,
                            speedLimit: this.parseSpeedLimit(way.tags.maxspeed),
                            type: 'speed_limit'
                        });
                    }
                    
                    // Traffic signals
                    if (way.tags.highway === 'traffic_signals') {
                        trafficData.signals.push({
                            way: way,
                            type: 'traffic_signal'
                        });
                    }
                    
                    // Construction
                    if (way.tags.construction) {
                        trafficData.construction.push({
                            way: way,
                            type: 'construction',
                            description: way.tags.construction
                        });
                    }
                    
                    // Road closures
                    if (way.tags.access === 'no' || way.tags.motor_vehicle === 'no') {
                        trafficData.closures.push({
                            way: way,
                            type: 'closure',
                            reason: way.tags.access === 'no' ? 'access_restricted' : 'motor_vehicle_restricted'
                        });
                    }
                    
                    // Bus lanes
                    if (way.tags.bus === 'yes') {
                        trafficData.busLanes.push({
                            way: way,
                            type: 'bus_lane'
                        });
                    }
                    
                    // One-way streets
                    if (way.tags.oneway === 'yes') {
                        trafficData.oneWay.push({
                            way: way,
                            type: 'one_way'
                        });
                    }
                }
            }
            
            processRelation(relation, trafficData) {
                if (relation.tags && relation.tags.type === 'restriction') {
                    trafficData.restrictions.push({
                        relation: relation,
                        type: 'restriction',
                        description: relation.tags.restriction
                    });
                }
            }
            
            parseSpeedLimit(maxspeed) {
                if (typeof maxspeed === 'number') return maxspeed;
                
                const match = maxspeed.toString().match(/(\d+)/);
                return match ? parseInt(match[1]) : 50; // Default 50 km/h
            }
            
            calculateTrafficImpact(trafficData, route) {
                const impact = {
                    totalSignals: trafficData.signals.length,
                    averageSpeedLimit: this.calculateAverageSpeedLimit(trafficData.speedLimits),
                    constructionZones: trafficData.construction.length,
                    roadClosures: trafficData.closures.length,
                    busLanes: trafficData.busLanes.length,
                    oneWayStreets: trafficData.oneWay.length,
                    trafficMultiplier: 1.0,
                    rawData: trafficData
                };
                
                // Calculate traffic impact multiplier
                impact.trafficMultiplier = this.calculateTrafficMultiplier(impact);
                
                return impact;
            }
            
            calculateAverageSpeedLimit(speedLimits) {
                if (speedLimits.length === 0) return 50; // Default
                
                const totalSpeed = speedLimits.reduce((sum, limit) => sum + limit.speedLimit, 0);
                return totalSpeed / speedLimits.length;
            }
            
            calculateTrafficMultiplier(impact) {
                let multiplier = 1.0;
                
                // Traffic signals slow down traffic
                multiplier += (impact.totalSignals * 0.05); // 5% per signal
                
                // Construction zones
                multiplier += (impact.constructionZones * 0.2); // 20% per construction zone
                
                // Road closures
                multiplier += (impact.roadClosures * 0.5); // 50% per closure
                
                // Bus lanes can improve traffic flow
                multiplier -= (impact.busLanes * 0.1); // 10% improvement per bus lane
                
                return Math.max(multiplier, 0.5); // Minimum 50% of normal speed
            }
        }

        // Global variables
        let map, startMarker, endMarker, routeLayer, trafficLayer;
        let startLocation = null, endLocation = null;
        let trafficProcessor = new TrafficDataProcessor();

        // Initialize map
        function initMap() {
            map = L.map('map').setView([40.7128, -74.0060], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);
            
            routeLayer = L.layerGroup().addTo(map);
            
            map.on('click', function(e) {
                if (!startLocation) {
                    setStartLocation(e.latlng.lat, e.latlng.lng);
                } else if (!endLocation) {
                    setEndLocation(e.latlng.lat, e.latlng.lng);
                } else {
                    setStartLocation(e.latlng.lat, e.latlng.lng);
                }
            });
        }

        // Set start location
        function setStartLocation(lat, lng) {
            startLocation = { lat, lng };
            if (startMarker) map.removeLayer(startMarker);
            startMarker = L.marker([lat, lng], {color: 'green'}).addTo(map);
            startMarker.bindPopup('Start Location').openPopup();
        }

        // Set end location
        function setEndLocation(lat, lng) {
            endLocation = { lat, lng };
            if (endMarker) map.removeLayer(endMarker);
            endMarker = L.marker([lat, lng], {color: 'red'}).addTo(map);
            endMarker.bindPopup('Destination').openPopup();
        }

        // Find route with traffic data
        async function findRoute() {
            if (!startLocation || !endLocation) {
                showToast('Please select both locations', 'warning');
                return;
            }

            showLoading(true);
            
            try {
                // Try OSRM routing service
                const response = await fetch(`https://router.project-osrm.org/route/v1/driving/${startLocation.lng},${startLocation.lat};${endLocation.lng},${endLocation.lat}?overview=full&geometries=geojson`);
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    
                    // Calculate bounds for traffic data
                    const bounds = calculateRouteBounds(route.geometry.coordinates);
                    
                    // Get traffic data
                    const trafficData = await trafficProcessor.processTrafficData(route, bounds);
                    
                    // Calculate traffic-adjusted time
                    const adjustedDuration = calculateTrafficAdjustedTime(route, trafficData);
                    
                    // Display route with traffic info
                    displayRoute(route.geometry.coordinates);
                    displayRouteInfo(route.distance, adjustedDuration, trafficData);
                    
                    // Display traffic elements on map
                    displayTrafficElements(trafficData);
                    
                } else {
                    showToast('No route found', 'error');
                }
            } catch (error) {
                console.error('Routing error:', error);
                showToast('Routing service unavailable', 'error');
            }
            
            showLoading(false);
        }

        // Display route on map
        function displayRoute(coordinates) {
            routeLayer.clearLayers();
            const latLngs = coordinates.map(coord => [coord[1], coord[0]]);
            L.polyline(latLngs, {color: 'blue', weight: 4}).addTo(routeLayer);
            map.fitBounds(L.polyline(latLngs).getBounds());
        }

        // Calculate route bounds for traffic data
        function calculateRouteBounds(coordinates) {
            let minLat = Infinity, maxLat = -Infinity;
            let minLng = Infinity, maxLng = -Infinity;
            
            coordinates.forEach(coord => {
                const [lng, lat] = coord;
                minLat = Math.min(minLat, lat);
                maxLat = Math.max(maxLat, lat);
                minLng = Math.min(minLng, lng);
                maxLng = Math.max(maxLng, lng);
            });
            
            // Add padding
            const padding = 0.01;
            return {
                south: minLat - padding,
                north: maxLat + padding,
                west: minLng - padding,
                east: maxLng + padding
            };
        }
        
        // Calculate traffic-adjusted time
        function calculateTrafficAdjustedTime(route, trafficData) {
            const baseDuration = route.duration; // seconds
            const adjustedDuration = baseDuration * trafficData.trafficMultiplier;
            return Math.round(adjustedDuration);
        }
        
        // Display route information with traffic data
        function displayRouteInfo(distance, duration, trafficData) {
            const distanceKm = (distance / 1000).toFixed(1);
            const durationMin = Math.round(duration / 60);
            const speedKmh = ((distance / 1000) / (duration / 3600)).toFixed(1);
            
            document.getElementById('distance').textContent = distanceKm + ' km';
            document.getElementById('duration').textContent = durationMin + ' min';
            document.getElementById('speed').textContent = speedKmh + ' km/h';
            
            // Display traffic information
            document.getElementById('traffic-impact').textContent = 
                (trafficData.trafficMultiplier * 100).toFixed(0) + '%';
            document.getElementById('traffic-signals').textContent = trafficData.totalSignals;
            document.getElementById('construction').textContent = trafficData.constructionZones;
            document.getElementById('closures').textContent = trafficData.roadClosures;
            
            document.getElementById('results').style.display = 'block';
        }

        // Display traffic elements on map
        function displayTrafficElements(trafficData) {
            // Clear existing traffic layer
            if (trafficLayer) {
                map.removeLayer(trafficLayer);
            }
            
            trafficLayer = L.layerGroup().addTo(map);
            
            // Display traffic signals
            trafficData.rawData.signals.forEach(signal => {
                if (signal.lat && signal.lng) {
                    const marker = L.marker([signal.lat, signal.lng], {
                        icon: L.divIcon({
                            className: 'traffic-signal-marker',
                            html: 'ðŸš¦',
                            iconSize: [20, 20]
                        })
                    }).addTo(trafficLayer);
                    marker.bindPopup('Traffic Signal');
                }
            });
            
            // Display construction zones
            trafficData.rawData.construction.forEach(construction => {
                if (construction.lat && construction.lng) {
                    const marker = L.marker([construction.lat, construction.lng], {
                        icon: L.divIcon({
                            className: 'construction-marker',
                            html: 'ðŸš§',
                            iconSize: [20, 20]
                        })
                    }).addTo(trafficLayer);
                    marker.bindPopup(`Construction: ${construction.description || 'Road work'}`);
                }
            });
            
            // Display road closures
            trafficData.rawData.closures.forEach(closure => {
                if (closure.way && closure.way.geometry) {
                    const coordinates = closure.way.geometry.coordinates.map(coord => [coord[1], coord[0]]);
                    L.polyline(coordinates, {
                        color: 'red',
                        weight: 3,
                        opacity: 0.7,
                        dashArray: '10, 10'
                    }).addTo(trafficLayer).bindPopup('Road Closure');
                }
            });
            
            // Display bus lanes
            trafficData.rawData.busLanes.forEach(busLane => {
                if (busLane.way && busLane.way.geometry) {
                    const coordinates = busLane.way.geometry.coordinates.map(coord => [coord[1], coord[0]]);
                    L.polyline(coordinates, {
                        color: 'orange',
                        weight: 2,
                        opacity: 0.6
                    }).addTo(trafficLayer).bindPopup('Bus Lane');
                }
            });
        }

        // Clear route
        function clearRoute() {
            if (startMarker) map.removeLayer(startMarker);
            if (endMarker) map.removeLayer(endMarker);
            routeLayer.clearLayers();
            if (trafficLayer) map.removeLayer(trafficLayer);
            startLocation = null;
            endLocation = null;
            document.getElementById('results').style.display = 'none';
            document.getElementById('start').value = '';
            document.getElementById('end').value = '';
        }

        // Show loading
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // Show toast notification
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Initialize when page loads
        window.onload = initMap;
    </script>
</body>
</html>
