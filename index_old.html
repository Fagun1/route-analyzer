<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Analyzer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #f5f5f5; }
        .container { display: flex; height: 100vh; }
        .sidebar { width: 300px; background: white; padding: 20px; overflow-y: auto; }
        .map { flex: 1; }
        
        #map { width: 100%; height: 100%; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .input-group input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        .btn { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
        .btn:hover { background: #0056b3; }
        .btn-secondary { background: #6c757d; }
        .btn-secondary:hover { background: #545b62; }
        .results { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; display: none; }
        .info { display: flex; justify-content: space-between; margin: 5px 0; }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 4px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: none; }
        .toast { position: fixed; top: 20px; right: 20px; background: #28a745; color: white; padding: 10px 20px; border-radius: 4px; z-index: 1000; }
        .toast.error { background: #dc3545; }
        .toast.warning { background: #ffc107; color: #000; }
        
        /* Traffic marker styles */
        .traffic-signal-marker {
            background: transparent;
            border: none;
            font-size: 16px;
        }
        
        .construction-marker {
            background: transparent;
            border: none;
            font-size: 16px;
        }
        
        .traffic-signal-marker:hover,
        .construction-marker:hover {
            transform: scale(1.2);
            transition: transform 0.2s ease;
        }
        
        /* User location marker styles */
        .user-location-marker {
            background: transparent;
            border: none;
            font-size: 20px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }
        
        .user-location-marker:hover {
            transform: scale(1.3);
            transition: transform 0.2s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h2>Route Planner</h2>
            
            <div class="input-group">
                <label>Start Location</label>
                <input type="text" id="start" placeholder="Enter start address">
            </div>
            
            <div class="input-group">
                <label>End Location</label>
                <input type="text" id="end" placeholder="Enter destination">
            </div>
            
            <button class="btn" onclick="findRoute()">Find Route</button>
            <button class="btn btn-secondary" onclick="getUserLocation()">üìç My Location</button>
            <button class="btn btn-secondary" onclick="clearRoute()">Clear</button>
            
            <hr style="margin: 20px 0; border: 1px solid #eee;">
            
            <h3>Random Location Generator</h3>
            <div class="input-group">
                <label>Number of Points</label>
                <input type="number" id="numPoints" placeholder="Enter number" min="1" max="10000" value="1000">
            </div>
            
            <div class="input-group">
                <label>Radius (km)</label>
                <input type="number" id="radiusKm" placeholder="Enter radius" min="0.1" max="1000" step="0.1" value="10">
            </div>
            
            <button class="btn" onclick="generateRandomLocations()">üé≤ Generate Points</button>
            <button class="btn btn-secondary" onclick="clearRandomPoints()">Clear Points</button>
            
            <div class="results" id="results">
                <h3>Route Details</h3>
                <div class="info">
                    <span>Distance:</span>
                    <span id="distance">--</span>
                </div>
                <div class="info">
                    <span>Duration:</span>
                    <span id="duration">--</span>
                </div>
                <div class="info">
                    <span>Speed:</span>
                    <span id="speed">--</span>
                </div>
                <div class="info">
                    <span>Traffic Impact:</span>
                    <span id="traffic-impact">--</span>
                </div>
                <div class="info">
                    <span>Traffic Signals:</span>
                    <span id="traffic-signals">--</span>
                </div>
                <div class="info">
                    <span>Construction:</span>
                    <span id="construction">--</span>
                </div>
                <div class="info">
                    <span>Road Closures:</span>
                    <span id="closures">--</span>
                </div>
            </div>
        </div>
        
        <div class="map">
            <div id="map"></div>
            <div class="loading" id="loading">Calculating route...</div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // OpenStreetMap Traffic Service
        class OpenStreetMapTrafficService {
            constructor() {
                this.baseUrl = 'https://overpass-api.de/api/interpreter';
                this.cache = new Map();
                this.cacheTimeout = 300000; // 5 minutes cache
            }
            
            async getTrafficData(bounds) {
                const cacheKey = this.getBoundsKey(bounds);
                const cached = this.cache.get(cacheKey);
                
                if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
                    return cached.data;
                }
                
                const query = this.buildTrafficQuery(bounds);
                const data = await this.executeQuery(query);
                
                this.cache.set(cacheKey, {
                    data: data,
                    timestamp: Date.now()
                });
                
                return data;
            }
            
            buildTrafficQuery(bounds) {
                return `
[out:json][timeout:25];
(
  // Traffic signals
  node["highway"="traffic_signals"](${bounds});
  way["highway"="traffic_signals"](${bounds});
  
  // Speed limits
  way["maxspeed"](${bounds});
  
  // Traffic calming measures
  way["traffic_calming"](${bounds});
  
  // Road restrictions
  relation["type"="restriction"](${bounds});
  
  // Construction zones
  way["construction"](${bounds});
  node["construction"](${bounds});
  
  // Road closures
  way["access"="no"](${bounds});
  way["motor_vehicle"="no"](${bounds});
  
  // Bus lanes
  way["bus"]="yes"(${bounds});
  
  // One-way streets
  way["oneway"]="yes"(${bounds});
);
out geom;
`;
            }
            
            async executeQuery(query) {
                try {
                    const response = await fetch(this.baseUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: `data=${encodeURIComponent(query)}`
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    return await response.json();
                } catch (error) {
                    console.error('Overpass API error:', error);
                    return { elements: [] };
                }
            }
            
            getBoundsKey(bounds) {
                return `${bounds.south},${bounds.west},${bounds.north},${bounds.east}`;
            }
        }

        // Traffic Data Processor
        class TrafficDataProcessor {
            constructor() {
                this.trafficService = new OpenStreetMapTrafficService();
            }
            
            async processTrafficData(route, bounds) {
                const rawData = await this.trafficService.getTrafficData(bounds);
                return this.analyzeTrafficElements(rawData.elements, route);
            }
            
            analyzeTrafficElements(elements, route) {
                const trafficData = {
                    signals: [],
                    speedLimits: [],
                    restrictions: [],
                    construction: [],
                    closures: [],
                    busLanes: [],
                    oneWay: []
                };
                
                elements.forEach(element => {
                    switch (element.type) {
                        case 'node':
                            this.processNode(element, trafficData);
                            break;
                        case 'way':
                            this.processWay(element, trafficData);
                            break;
                        case 'relation':
                            this.processRelation(element, trafficData);
                            break;
                    }
                });
                
                return this.calculateTrafficImpact(trafficData, route);
            }
            
            processNode(node, trafficData) {
                if (node.tags) {
                    if (node.tags.highway === 'traffic_signals') {
                        trafficData.signals.push({
                            lat: node.lat,
                            lng: node.lon,
                            type: 'traffic_signal'
                        });
                    }
                    
                    if (node.tags.construction) {
                        trafficData.construction.push({
                            lat: node.lat,
                            lng: node.lon,
                            type: 'construction',
                            description: node.tags.construction
                        });
                    }
                }
            }
            
            processWay(way, trafficData) {
                if (way.tags) {
                    // Speed limits
                    if (way.tags.maxspeed) {
                        trafficData.speedLimits.push({
                            way: way,
                            speedLimit: this.parseSpeedLimit(way.tags.maxspeed),
                            type: 'speed_limit'
                        });
                    }
                    
                    // Traffic signals
                    if (way.tags.highway === 'traffic_signals') {
                        trafficData.signals.push({
                            way: way,
                            type: 'traffic_signal'
                        });
                    }
                    
                    // Construction
                    if (way.tags.construction) {
                        trafficData.construction.push({
                            way: way,
                            type: 'construction',
                            description: way.tags.construction
                        });
                    }
                    
                    // Road closures
                    if (way.tags.access === 'no' || way.tags.motor_vehicle === 'no') {
                        trafficData.closures.push({
                            way: way,
                            type: 'closure',
                            reason: way.tags.access === 'no' ? 'access_restricted' : 'motor_vehicle_restricted'
                        });
                    }
                    
                    // Bus lanes
                    if (way.tags.bus === 'yes') {
                        trafficData.busLanes.push({
                            way: way,
                            type: 'bus_lane'
                        });
                    }
                    
                    // One-way streets
                    if (way.tags.oneway === 'yes') {
                        trafficData.oneWay.push({
                            way: way,
                            type: 'one_way'
                        });
                    }
                }
            }
            
            processRelation(relation, trafficData) {
                if (relation.tags && relation.tags.type === 'restriction') {
                    trafficData.restrictions.push({
                        relation: relation,
                        type: 'restriction',
                        description: relation.tags.restriction
                    });
                }
            }
            
            parseSpeedLimit(maxspeed) {
                if (typeof maxspeed === 'number') return maxspeed;
                
                const match = maxspeed.toString().match(/(\d+)/);
                return match ? parseInt(match[1]) : 50; // Default 50 km/h
            }
            
            calculateTrafficImpact(trafficData, route) {
                const impact = {
                    totalSignals: trafficData.signals.length,
                    averageSpeedLimit: this.calculateAverageSpeedLimit(trafficData.speedLimits),
                    constructionZones: trafficData.construction.length,
                    roadClosures: trafficData.closures.length,
                    busLanes: trafficData.busLanes.length,
                    oneWayStreets: trafficData.oneWay.length,
                    trafficMultiplier: 1.0,
                    rawData: trafficData
                };
                
                // Calculate traffic impact multiplier
                impact.trafficMultiplier = this.calculateTrafficMultiplier(impact);
                
                return impact;
            }
            
            calculateAverageSpeedLimit(speedLimits) {
                if (speedLimits.length === 0) return 50; // Default
                
                const totalSpeed = speedLimits.reduce((sum, limit) => sum + limit.speedLimit, 0);
                return totalSpeed / speedLimits.length;
            }
            
            calculateTrafficMultiplier(impact) {
                let multiplier = 1.0;
                
                // Traffic signals slow down traffic
                multiplier += (impact.totalSignals * 0.05); // 5% per signal
                
                // Construction zones
                multiplier += (impact.constructionZones * 0.2); // 20% per construction zone
                
                // Road closures
                multiplier += (impact.roadClosures * 0.5); // 50% per closure
                
                // Bus lanes can improve traffic flow
                multiplier -= (impact.busLanes * 0.1); // 10% improvement per bus lane
                
                return Math.max(multiplier, 0.5); // Minimum 50% of normal speed
            }
        }

        // Global variables
        let map, startMarker, endMarker, routeLayer, trafficLayer, userMarker, randomPointsLayer;
        let startLocation = null, endLocation = null;
        let trafficProcessor = new TrafficDataProcessor();
        let randomPoints = [];

        // Initialize map
        function initMap() {
            // Default location (New York City)
            const defaultLocation = [40.7128, -74.0060];
            const defaultZoom = 13;
            
            map = L.map('map').setView(defaultLocation, defaultZoom);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
            
            routeLayer = L.layerGroup().addTo(map);
            randomPointsLayer = L.layerGroup().addTo(map);
            
            // Request user's location
            getUserLocation();
            
            map.on('click', function(e) {
                if (!startLocation) {
                    setStartLocation(e.latlng.lat, e.latlng.lng);
                } else if (!endLocation) {
                    setEndLocation(e.latlng.lat, e.latlng.lng);
                } else {
                    setStartLocation(e.latlng.lat, e.latlng.lng);
                }
            });
        }

        // Get user's current location
        function getUserLocation() {
            if (navigator.geolocation) {
                showToast('Requesting your location...', 'success');
                
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        const userLat = position.coords.latitude;
                        const userLng = position.coords.longitude;
                        
                        // Center map on user's location
                        map.setView([userLat, userLng], 15);
                        
                        // Remove existing user marker if it exists
                        if (userMarker) {
                            map.removeLayer(userMarker);
                        }
                        
                        // Add a marker for user's location
                        userMarker = L.marker([userLat, userLng], {
                            icon: L.divIcon({
                                className: 'user-location-marker',
                                html: 'üìç',
                                iconSize: [25, 25]
                            })
                        }).addTo(map);
                        userMarker.bindPopup('Your Location').openPopup();
                        
                        showToast('Location found! Map centered on your position.', 'success');
                    },
                    function(error) {
                        console.error('Geolocation error:', error);
                        let errorMessage = 'Unable to get your location. ';
                        
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                errorMessage += 'Location access denied by user.';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMessage += 'Location information unavailable.';
                                break;
                            case error.TIMEOUT:
                                errorMessage += 'Location request timed out.';
                                break;
                            default:
                                errorMessage += 'Unknown error occurred.';
                                break;
                        }
                        
                        showToast(errorMessage, 'warning');
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 300000 // 5 minutes
                    }
                );
            } else {
                showToast('Geolocation is not supported by this browser.', 'warning');
            }
        }

        // Set start location
        function setStartLocation(lat, lng) {
            startLocation = { lat, lng };
            if (startMarker) map.removeLayer(startMarker);
            startMarker = L.marker([lat, lng], {color: 'green'}).addTo(map);
            startMarker.bindPopup('Start Location').openPopup();
        }

        // Set end location
        function setEndLocation(lat, lng) {
            endLocation = { lat, lng };
            if (endMarker) map.removeLayer(endMarker);
            endMarker = L.marker([lat, lng], {color: 'red'}).addTo(map);
            endMarker.bindPopup('Destination').openPopup();
        }

        // Find route with traffic data
        async function findRoute() {
            if (!startLocation || !endLocation) {
                showToast('Please select both locations', 'warning');
                return;
            }

            showLoading(true);
            
            try {
                // Try OSRM routing service
                const response = await fetch(`https://router.project-osrm.org/route/v1/driving/${startLocation.lng},${startLocation.lat};${endLocation.lng},${endLocation.lat}?overview=full&geometries=geojson`);
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    
                    // Calculate bounds for traffic data
                    const bounds = calculateRouteBounds(route.geometry.coordinates);
                    
                    // Get traffic data
                    const trafficData = await trafficProcessor.processTrafficData(route, bounds);
                    
                    // Calculate traffic-adjusted time
                    const adjustedDuration = calculateTrafficAdjustedTime(route, trafficData);
                    
                    // Display route with traffic info
                    displayRoute(route.geometry.coordinates);
                    displayRouteInfo(route.distance, adjustedDuration, trafficData);
                    
                    // Display traffic elements on map
                    displayTrafficElements(trafficData);
                    
                } else {
                    showToast('No route found', 'error');
                }
            } catch (error) {
                console.error('Routing error:', error);
                showToast('Routing service unavailable', 'error');
            }
            
            showLoading(false);
        }

        // Display route on map
        function displayRoute(coordinates) {
            routeLayer.clearLayers();
            const latLngs = coordinates.map(coord => [coord[1], coord[0]]);
            L.polyline(latLngs, {color: 'blue', weight: 4}).addTo(routeLayer);
            map.fitBounds(L.polyline(latLngs).getBounds());
        }

        // Calculate route bounds for traffic data
        function calculateRouteBounds(coordinates) {
            let minLat = Infinity, maxLat = -Infinity;
            let minLng = Infinity, maxLng = -Infinity;
            
            coordinates.forEach(coord => {
                const [lng, lat] = coord;
                minLat = Math.min(minLat, lat);
                maxLat = Math.max(maxLat, lat);
                minLng = Math.min(minLng, lng);
                maxLng = Math.max(maxLng, lng);
            });
            
            // Add padding
            const padding = 0.01;
            return {
                south: minLat - padding,
                north: maxLat + padding,
                west: minLng - padding,
                east: maxLng + padding
            };
        }
        
        // Calculate traffic-adjusted time
        function calculateTrafficAdjustedTime(route, trafficData) {
            const baseDuration = route.duration; // seconds
            const adjustedDuration = baseDuration * trafficData.trafficMultiplier;
            return Math.round(adjustedDuration);
        }
        
        // Display route information with traffic data
        function displayRouteInfo(distance, duration, trafficData) {
            const distanceKm = (distance / 1000).toFixed(1);
            const durationMin = Math.round(duration / 60);
            const speedKmh = ((distance / 1000) / (duration / 3600)).toFixed(1);
            
            document.getElementById('distance').textContent = distanceKm + ' km';
            document.getElementById('duration').textContent = durationMin + ' min';
            document.getElementById('speed').textContent = speedKmh + ' km/h';
            
            // Display traffic information
            document.getElementById('traffic-impact').textContent = 
                (trafficData.trafficMultiplier * 100).toFixed(0) + '%';
            document.getElementById('traffic-signals').textContent = trafficData.totalSignals;
            document.getElementById('construction').textContent = trafficData.constructionZones;
            document.getElementById('closures').textContent = trafficData.roadClosures;
            
            document.getElementById('results').style.display = 'block';
        }

        // Display traffic elements on map
        function displayTrafficElements(trafficData) {
            // Clear existing traffic layer
            if (trafficLayer) {
                map.removeLayer(trafficLayer);
            }
            
            trafficLayer = L.layerGroup().addTo(map);
            
            // Display traffic signals
            trafficData.rawData.signals.forEach(signal => {
                if (signal.lat && signal.lng) {
                    const marker = L.marker([signal.lat, signal.lng], {
                        icon: L.divIcon({
                            className: 'traffic-signal-marker',
                            html: 'üö¶',
                            iconSize: [20, 20]
                        })
                    }).addTo(trafficLayer);
                    marker.bindPopup('Traffic Signal');
                }
            });
            
            // Display construction zones
            trafficData.rawData.construction.forEach(construction => {
                if (construction.lat && construction.lng) {
                    const marker = L.marker([construction.lat, construction.lng], {
                        icon: L.divIcon({
                            className: 'construction-marker',
                            html: 'üöß',
                            iconSize: [20, 20]
                        })
                    }).addTo(trafficLayer);
                    marker.bindPopup(`Construction: ${construction.description || 'Road work'}`);
                }
            });
            
            // Display road closures
            trafficData.rawData.closures.forEach(closure => {
                if (closure.way && closure.way.geometry) {
                    const coordinates = closure.way.geometry.coordinates.map(coord => [coord[1], coord[0]]);
                    L.polyline(coordinates, {
                        color: 'red',
                        weight: 3,
                        opacity: 0.7,
                        dashArray: '10, 10'
                    }).addTo(trafficLayer).bindPopup('Road Closure');
                }
            });
            
            // Display bus lanes
            trafficData.rawData.busLanes.forEach(busLane => {
                if (busLane.way && busLane.way.geometry) {
                    const coordinates = busLane.way.geometry.coordinates.map(coord => [coord[1], coord[0]]);
                    L.polyline(coordinates, {
                        color: 'orange',
                        weight: 2,
                        opacity: 0.6
                    }).addTo(trafficLayer).bindPopup('Bus Lane');
                }
            });
        }

        // Clear route
        function clearRoute() {
            if (startMarker) map.removeLayer(startMarker);
            if (endMarker) map.removeLayer(endMarker);
            routeLayer.clearLayers();
            if (trafficLayer) map.removeLayer(trafficLayer);
            startLocation = null;
            endLocation = null;
            document.getElementById('results').style.display = 'none';
            document.getElementById('start').value = '';
            document.getElementById('end').value = '';
            // Note: userMarker and randomPointsLayer are intentionally not removed
        }

        // Show loading
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // Show toast notification
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Ultra-Fast Random Location Generator
        function generateRandomLocations() {
            const numPoints = parseInt(document.getElementById('numPoints').value);
            const radiusKm = parseFloat(document.getElementById('radiusKm').value);
            
            if (!numPoints || !radiusKm || numPoints < 1 || radiusKm <= 0) {
                showToast('Please enter valid number of points and radius', 'warning');
                return;
            }
            
            if (!userMarker) {
                showToast('Please get your location first', 'warning');
                return;
            }
            
            const startTime = performance.now();
            showLoading(true);
            showToast(`Generating ${numPoints} random points within ${radiusKm}km...`, 'success');
            
            try {
                // Get user's location from the marker
                const userLat = userMarker.getLatLng().lat;
                const userLng = userMarker.getLatLng().lng;
                
                // Clear existing random points
                clearRandomPoints();
                
                // Generate random points using ultra-fast algorithm
                const generatedPoints = generatePointsUltraFast(userLat, userLng, radiusKm, numPoints);
                
                // Display points on map
                displayRandomPoints(generatedPoints);
                
                const endTime = performance.now();
                const duration = ((endTime - startTime) / 1000).toFixed(3);
                
                showToast(`Successfully generated ${generatedPoints.length} points in ${duration}s!`, 'success');
                
            } catch (error) {
                console.error('Error generating random locations:', error);
                showToast('Error generating random locations', 'error');
            }
            
            showLoading(false);
        }
        
        // Ultra-Fast Point Generation Algorithm
        function generatePointsUltraFast(centerLat, centerLng, radiusKm, numPoints) {
            const points = [];
            const radiusDegrees = radiusKm / 111; // Convert km to degrees
            
            // Pre-calculate common values for performance
            const cosLat = Math.cos(centerLat * Math.PI / 180);
            const maxLat = centerLat + radiusDegrees;
            const minLat = centerLat - radiusDegrees;
            const maxLng = centerLng + radiusDegrees / cosLat;
            const minLng = centerLng - radiusDegrees / cosLat;
            
            // Generate points using optimized algorithms
            for (let i = 0; i < numPoints; i++) {
                const point = generateOptimizedRandomPoint(
                    centerLat, centerLng, radiusKm, 
                    minLat, maxLat, minLng, maxLng
                );
                
                // Fast mathematical validation (no API calls)
                if (isPointValidFast(point.lat, point.lng)) {
                    points.push(point);
                }
            }
            
            return points;
        }
        
        // Optimized random point generation
        function generateOptimizedRandomPoint(centerLat, centerLng, radiusKm, minLat, maxLat, minLng, maxLng) {
            // Use rejection sampling for uniform distribution in circle
            let lat, lng, distance;
            
            do {
                // Generate random point in bounding box
                lat = minLat + Math.random() * (maxLat - minLat);
                lng = minLng + Math.random() * (maxLng - minLng);
                
                // Calculate distance from center
                distance = calculateDistance(centerLat, centerLng, lat, lng);
            } while (distance > radiusKm);
            
            return { lat, lng };
        }
        
        // Fast distance calculation (Haversine formula optimized)
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Ultra-fast point validation using mathematical heuristics
        function isPointValidFast(lat, lng) {
            // Fast mathematical validation instead of API calls
            
            // 1. Check if point is within reasonable geographic bounds
            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                return false;
            }
            
            // 2. Simple validation - just avoid extreme polar regions
            if (Math.abs(lat) > 85) {
                return false;
            }
            
            // 3. Accept most points for DSA demonstration purposes
            // 98% acceptance rate for algorithm testing
            return Math.random() < 0.98;
        }
        
        
        // Optimized display for thousands of points
        function displayRandomPoints(points) {
            randomPointsLayer.clearLayers();
            randomPoints = points;
            
            // For large numbers of points, use optimized rendering
            if (points.length > 1000) {
                displayPointsOptimized(points);
            } else {
                displayPointsDetailed(points);
            }
            
            // Fit map to show all points
            if (points.length > 0) {
                const group = new L.featureGroup(randomPointsLayer.getLayers());
                map.fitBounds(group.getBounds().pad(0.1));
            }
        }
        
        // Detailed display for smaller numbers of points
        function displayPointsDetailed(points) {
            points.forEach((point, index) => {
                const marker = L.circleMarker([point.lat, point.lng], {
                    radius: 6,
                    fillColor: '#ff6b6b',
                    color: '#d63031',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(randomPointsLayer);
                
                marker.bindPopup(`Random Point ${index + 1}<br>Lat: ${point.lat.toFixed(6)}<br>Lng: ${point.lng.toFixed(6)}`);
            });
        }
        
        // Optimized display for thousands of points
        function displayPointsOptimized(points) {
            // Use smaller, simpler markers for performance
            points.forEach((point, index) => {
                const marker = L.circleMarker([point.lat, point.lng], {
                    radius: 3,
                    fillColor: '#ff6b6b',
                    color: '#d63031',
                    weight: 1,
                    opacity: 0.8,
                    fillOpacity: 0.6
                }).addTo(randomPointsLayer);
                
                // Only add popup for every 100th point to avoid performance issues
                if (index % 100 === 0) {
                    marker.bindPopup(`Random Point ${index + 1}<br>Lat: ${point.lat.toFixed(6)}<br>Lng: ${point.lng.toFixed(6)}`);
                }
            });
        }
        
        // Clear random points
        function clearRandomPoints() {
            randomPointsLayer.clearLayers();
            randomPoints = [];
        }

        // Initialize when page loads
        window.onload = initMap;
    </script>
</body>
</html>
